package hdf5

import (
	"errors"
	"os"
	"os/exec"
	"strings"
	"testing"

	"github.com/batchatco/go-native-netcdf/netcdf/api"
	"github.com/batchatco/go-native-netcdf/netcdf/util"
)

const (
	ncdumpBinary = "ncdump"
)

// filterAttributes removes underscore-prefixed names from the attribute map,
// as they are reserved for system use and not allowed for users.
func filterAttributes(am api.AttributeMap) api.AttributeMap {
	if am == nil {
		return nil
	}
	keys := []string{}
	values := map[string]any{}
	for _, k := range am.Keys() {
		if strings.HasPrefix(k, "_") {
			continue
		}
		val, _ := am.Get(k)
		keys = append(keys, k)
		values[k] = val
	}
	res, _ := util.NewOrderedMap(keys, values)
	return res
}

// copyGroup recursively copies variables, attributes, and subgroups
// from a reader group to a writer group.
func copyGroup(t *testing.T, r api.Group, w api.Writer) {
	t.Helper()
	attrs := r.Attributes()
	attrs = filterAttributes(attrs)
	if attrs != nil && len(attrs.Keys()) > 0 {
		err := w.AddAttributes(attrs)
		if err != nil {
			t.Fatalf("AddAttributes: %v", err)
		}
	}
	vars := r.ListVariables()
	for _, name := range vars {
		vr, err := r.GetVariable(name)
		if err != nil {
			t.Fatalf("GetVariable(%s): %v", name, err)
		}
		err = w.AddVar(name, api.Variable{
			Values:     vr.Values,
			Dimensions: vr.Dimensions,
			Attributes: filterAttributes(vr.Attributes),
		})
		if err != nil {
			t.Fatalf("AddVar(%s): %v", name, err)
		}
	}
	subgroups := r.ListSubgroups()
	for _, gname := range subgroups {
		rg, err := r.GetGroup(gname)
		if err != nil {
			t.Fatalf("GetGroup(%s): %v", gname, err)
		}
		wg, err := w.CreateGroup(gname)
		if err != nil {
			t.Fatalf("CreateGroup(%s): %v", gname, err)
		}
		copyGroup(t, rg, wg)
	}
}

// roundtrip reads a .nc file (generated by ncgen), writes it using
// our HDF5 writer, then validates the output with external tools.
func roundtrip(t *testing.T, cdlName string) {
	t.Helper()

	// Generate .nc from .cdl using ncgen
	srcFile := ncGen(t, cdlName)
	if srcFile == "" {
		t.Fatalf("ncgen failed for %s", cdlName)
	}
	defer os.Remove(srcFile)

	// Read with our reader
	nc, err := Open(srcFile)
	if err != nil {
		t.Fatalf("Open(%s): %v", srcFile, err)
	}

	// Write with our writer
	outFile := "testdata/" + cdlName + "_out.h5"
	w, err := OpenWriter(outFile)
	if err != nil {
		nc.Close()
		t.Fatalf("OpenWriter(%s): %v", outFile, err)
	}
	copyGroup(t, nc, w)
	err = w.Close()
	nc.Close()
	if err != nil {
		t.Fatalf("writer Close: %v", err)
	}
	defer os.Remove(outFile)

	// Validate with h5dump (checks HDF5 structural validity)
	cmd := exec.Command(h5DumpBinary, "-H", outFile)
	output, err := cmd.CombinedOutput()
	if err != nil {
		t.Errorf("h5dump -H failed for %s: %v\n%s", outFile, err, string(output))
	}

	// Validate with h5dump full data dump
	cmd = exec.Command(h5DumpBinary, outFile)
	output, err = cmd.CombinedOutput()
	if err != nil {
		t.Errorf("h5dump (full) failed for %s: %v\n%s", outFile, err, string(output))
	}

	// Validate with ncdump (checks NetCDF4 compatibility)
	cmd = exec.Command(ncdumpBinary, outFile)
	output, err = cmd.CombinedOutput()
	if err != nil {
		t.Errorf("ncdump failed for %s: %v\n%s", outFile, err, string(output))
	}

	// Check ncdump output doesn't have phony_dim (indicates missing dim scales)
	if strings.Contains(string(output), "phony_dim") {
		t.Errorf("ncdump output contains phony_dim for %s (dimension scales not recognized)", outFile)
	}

	// Validate with h5repack (roundtrip through HDF5 C library)
	repackFile := "testdata/" + cdlName + "_repack.h5"
	cmd = exec.Command(h5RepackBinary, outFile, repackFile)
	output, err = cmd.CombinedOutput()
	if err != nil {
		t.Errorf("h5repack failed for %s: %v\n%s", outFile, err, string(output))
	}
	defer os.Remove(repackFile)

	// Re-read the written file with our reader and verify data roundtrips
	nc2, err := Open(outFile)
	if err != nil {
		t.Fatalf("Open (re-read) %s: %v", outFile, err)
	}
	defer nc2.Close()

	// Re-read original for comparison
	nc1, err := Open(srcFile)
	if err != nil {
		t.Fatalf("Open (original) %s: %v", srcFile, err)
	}
	defer nc1.Close()

	compareGroups(t, "", nc1, nc2)
}

// compareGroups recursively compares variables and subgroups between
// an original and roundtripped file.
func compareGroups(t *testing.T, path string, orig api.Group, got api.Group) {
	t.Helper()

	// Compare variables
	origVars := orig.ListVariables()
	gotVars := got.ListVariables()
	if len(origVars) != len(gotVars) {
		t.Errorf("%s: variable count mismatch: orig=%d got=%d (orig=%v got=%v)",
			path, len(origVars), len(gotVars), origVars, gotVars)
		return
	}
	for _, name := range origVars {
		origV, err := orig.GetVariable(name)
		if err != nil {
			t.Errorf("%s: GetVariable(%s) from original: %v", path, name, err)
			continue
		}
		gotV, err := got.GetVariable(name)
		if err != nil {
			t.Errorf("%s: GetVariable(%s) from roundtrip: %v", path, name, err)
			continue
		}
		// Compare dimensions
		if len(origV.Dimensions) != len(gotV.Dimensions) {
			t.Errorf("%s/%s: dimension count mismatch: orig=%v got=%v",
				path, name, origV.Dimensions, gotV.Dimensions)
		}
	}

	// Compare subgroups recursively
	origGroups := orig.ListSubgroups()
	gotGroups := got.ListSubgroups()
	if len(origGroups) != len(gotGroups) {
		t.Errorf("%s: subgroup count mismatch: orig=%d got=%d",
			path, len(origGroups), len(gotGroups))
		return
	}
	for _, gname := range origGroups {
		origG, err := orig.GetGroup(gname)
		if err != nil {
			t.Errorf("%s: GetGroup(%s) from original: %v", path, gname, err)
			continue
		}
		gotG, err := got.GetGroup(gname)
		if err != nil {
			t.Errorf("%s: GetGroup(%s) from roundtrip: %v", path, gname, err)
			continue
		}
		compareGroups(t, path+"/"+gname, origG, gotG)
	}
}

func TestWriterRoundtripAllTypes(t *testing.T) {
	roundtrip(t, "test_alltypes")
}

func TestWriterRoundtripFillValues(t *testing.T) {
	roundtrip(t, "test_fillvalues")
}

func TestWriterRoundtripGroups(t *testing.T) {
	roundtrip(t, "test_groups")
}

func TestWriterRoundtripStrings(t *testing.T) {
	roundtrip(t, "test_strings")
}

func TestWriterRoundtripMultiDim(t *testing.T) {
	roundtrip(t, "test_multidim")
}

func TestWriterRoundtripCompound(t *testing.T) {
	roundtrip(t, "testcompounds")
}

func TestWriterRoundtripEnum(t *testing.T) {
	roundtrip(t, "testenum")
}

func TestWriterRoundtripOpaque(t *testing.T) {
	roundtrip(t, "testopaque")
}

func TestWriterRoundtripVlen(t *testing.T) {
	roundtrip(t, "testvlen")
}

func TestWriterRejectsUnsupportedTypes(t *testing.T) {
	outFile := "testdata/unsupported_type_test.h5"
	w, err := OpenWriter(outFile)
	if err != nil {
		t.Fatalf("OpenWriter: %v", err)
	}
	defer os.Remove(outFile)
	defer w.Close()

	unsupported := []struct {
		name string
		val  any
	}{
		{"bool", true},
		{"int", int(42)},
		{"uint", uint(42)},
		{"complex64", complex64(1 + 2i)},
		{"complex128", complex128(1 + 2i)},
		{"bools", []bool{true, false}},
		{"complex128s", []complex128{1 + 2i}},
		{"ints", []int{1, 2, 3}},
	}

	for _, tc := range unsupported {
		err := w.AddVar(tc.name, api.Variable{Values: tc.val})
		if err == nil {
			t.Errorf("AddVar(%s) should have returned an error for type %T", tc.name, tc.val)
			continue
		}
		if !errors.Is(err, ErrUnsupportedType) {
			t.Errorf("AddVar(%s) error should wrap ErrUnsupportedType, got: %v", tc.name, err)
		}
	}

	// Verify supported types are still accepted
	supported := []struct {
		name string
		val  any
	}{
		{"i8", int8(1)},
		{"u8", uint8(1)},
		{"i16", int16(1)},
		{"u16", uint16(1)},
		{"i32", int32(1)},
		{"u32", uint32(1)},
		{"i64", int64(1)},
		{"u64", uint64(1)},
		{"f32", float32(1.0)},
		{"f64", float64(1.0)},
		{"str", "hello"},
		{"sliceI32", []int32{1, 2, 3}},
		{"sliceF64", []float64{1.0, 2.0}},
		{"sliceStr", []string{"a", "b"}},
	}

	for _, tc := range supported {
		err := w.AddVar(tc.name, api.Variable{Values: tc.val})
		if err != nil {
			t.Errorf("AddVar(%s) should have accepted type %T, got: %v", tc.name, tc.val, err)
		}
	}
}

func TestWriterRejectsUnsupportedAttributeTypes(t *testing.T) {
	outFile := "testdata/unsupported_attr_test.h5"
	w, err := OpenWriter(outFile)
	if err != nil {
		t.Fatalf("OpenWriter: %v", err)
	}
	defer os.Remove(outFile)
	defer w.Close()

	attrs, _ := util.NewOrderedMap(
		[]string{"bad"},
		map[string]any{"bad": true},
	)
	err = w.AddAttributes(attrs)
	if err == nil {
		t.Error("AddAttributes should have returned an error for bool attribute")
	} else if !errors.Is(err, ErrUnsupportedType) {
		t.Errorf("AddAttributes error should wrap ErrUnsupportedType, got: %v", err)
	}

	// Also test via AddVar attribute
	err = w.AddVar("x", api.Variable{
		Values:     int32(1),
		Attributes: attrs,
	})
	if err == nil {
		t.Error("AddVar should have returned an error for bool attribute")
	} else if !errors.Is(err, ErrUnsupportedType) {
		t.Errorf("AddVar error should wrap ErrUnsupportedType, got: %v", err)
	}
}
