package hdf5

import (
	"os"
	"os/exec"
	"strings"
	"testing"

	"github.com/batchatco/go-native-netcdf/netcdf/api"
)

const (
	ncdumpBinary = "ncdump"
)

// copyGroup recursively copies variables, attributes, and subgroups
// from a reader group to a writer group.
func copyGroup(t *testing.T, r api.Group, w api.Writer) {
	t.Helper()
	attrs := r.Attributes()
	if attrs != nil && len(attrs.Keys()) > 0 {
		err := w.AddAttributes(attrs)
		if err != nil {
			t.Fatalf("AddAttributes: %v", err)
		}
	}
	vars := r.ListVariables()
	for _, name := range vars {
		vr, err := r.GetVariable(name)
		if err != nil {
			t.Fatalf("GetVariable(%s): %v", name, err)
		}
		err = w.AddVar(name, api.Variable{
			Values:     vr.Values,
			Dimensions: vr.Dimensions,
			Attributes: vr.Attributes,
		})
		if err != nil {
			t.Fatalf("AddVar(%s): %v", name, err)
		}
	}
	subgroups := r.ListSubgroups()
	for _, gname := range subgroups {
		rg, err := r.GetGroup(gname)
		if err != nil {
			t.Fatalf("GetGroup(%s): %v", gname, err)
		}
		wg, err := w.CreateGroup(gname)
		if err != nil {
			t.Fatalf("CreateGroup(%s): %v", gname, err)
		}
		copyGroup(t, rg, wg)
	}
}

// roundtrip reads a .nc file (generated by ncgen), writes it using
// our HDF5 writer, then validates the output with external tools.
func roundtrip(t *testing.T, cdlName string) {
	t.Helper()

	// Generate .nc from .cdl using ncgen
	srcFile := ncGen(t, cdlName)
	if srcFile == "" {
		t.Fatalf("ncgen failed for %s", cdlName)
	}
	defer os.Remove(srcFile)

	// Read with our reader
	nc, err := Open(srcFile)
	if err != nil {
		t.Fatalf("Open(%s): %v", srcFile, err)
	}

	// Write with our writer
	outFile := "testdata/" + cdlName + "_out.h5"
	w, err := OpenWriter(outFile)
	if err != nil {
		nc.Close()
		t.Fatalf("OpenWriter(%s): %v", outFile, err)
	}
	copyGroup(t, nc, w)
	err = w.Close()
	nc.Close()
	if err != nil {
		t.Fatalf("writer Close: %v", err)
	}
	defer os.Remove(outFile)

	// Validate with h5dump (checks HDF5 structural validity)
	cmd := exec.Command(h5DumpBinary, "-H", outFile)
	output, err := cmd.CombinedOutput()
	if err != nil {
		t.Errorf("h5dump -H failed for %s: %v\n%s", outFile, err, string(output))
	}

	// Validate with h5dump full data dump
	cmd = exec.Command(h5DumpBinary, outFile)
	output, err = cmd.CombinedOutput()
	if err != nil {
		t.Errorf("h5dump (full) failed for %s: %v\n%s", outFile, err, string(output))
	}

	// Validate with ncdump (checks NetCDF4 compatibility)
	cmd = exec.Command(ncdumpBinary, outFile)
	output, err = cmd.CombinedOutput()
	if err != nil {
		t.Errorf("ncdump failed for %s: %v\n%s", outFile, err, string(output))
	}

	// Check ncdump output doesn't have phony_dim (indicates missing dim scales)
	if strings.Contains(string(output), "phony_dim") {
		t.Errorf("ncdump output contains phony_dim for %s (dimension scales not recognized)", outFile)
	}

	// Validate with h5repack (roundtrip through HDF5 C library)
	repackFile := "testdata/" + cdlName + "_repack.h5"
	cmd = exec.Command(h5RepackBinary, outFile, repackFile)
	output, err = cmd.CombinedOutput()
	if err != nil {
		t.Errorf("h5repack failed for %s: %v\n%s", outFile, err, string(output))
	}
	defer os.Remove(repackFile)

	// Re-read the written file with our reader and verify data roundtrips
	nc2, err := Open(outFile)
	if err != nil {
		t.Fatalf("Open (re-read) %s: %v", outFile, err)
	}
	defer nc2.Close()

	// Re-read original for comparison
	nc1, err := Open(srcFile)
	if err != nil {
		t.Fatalf("Open (original) %s: %v", srcFile, err)
	}
	defer nc1.Close()

	compareGroups(t, "", nc1, nc2)
}

// compareGroups recursively compares variables and subgroups between
// an original and roundtripped file.
func compareGroups(t *testing.T, path string, orig api.Group, got api.Group) {
	t.Helper()

	// Compare variables
	origVars := orig.ListVariables()
	gotVars := got.ListVariables()
	if len(origVars) != len(gotVars) {
		t.Errorf("%s: variable count mismatch: orig=%d got=%d (orig=%v got=%v)",
			path, len(origVars), len(gotVars), origVars, gotVars)
		return
	}
	for _, name := range origVars {
		origV, err := orig.GetVariable(name)
		if err != nil {
			t.Errorf("%s: GetVariable(%s) from original: %v", path, name, err)
			continue
		}
		gotV, err := got.GetVariable(name)
		if err != nil {
			t.Errorf("%s: GetVariable(%s) from roundtrip: %v", path, name, err)
			continue
		}
		// Compare dimensions
		if len(origV.Dimensions) != len(gotV.Dimensions) {
			t.Errorf("%s/%s: dimension count mismatch: orig=%v got=%v",
				path, name, origV.Dimensions, gotV.Dimensions)
		}
	}

	// Compare subgroups recursively
	origGroups := orig.ListSubgroups()
	gotGroups := got.ListSubgroups()
	if len(origGroups) != len(gotGroups) {
		t.Errorf("%s: subgroup count mismatch: orig=%d got=%d",
			path, len(origGroups), len(gotGroups))
		return
	}
	for _, gname := range origGroups {
		origG, err := orig.GetGroup(gname)
		if err != nil {
			t.Errorf("%s: GetGroup(%s) from original: %v", path, gname, err)
			continue
		}
		gotG, err := got.GetGroup(gname)
		if err != nil {
			t.Errorf("%s: GetGroup(%s) from roundtrip: %v", path, gname, err)
			continue
		}
		compareGroups(t, path+"/"+gname, origG, gotG)
	}
}

func TestWriterRoundtripAllTypes(t *testing.T) {
	roundtrip(t, "test_alltypes")
}

func TestWriterRoundtripFillValues(t *testing.T) {
	roundtrip(t, "test_fillvalues")
}

func TestWriterRoundtripGroups(t *testing.T) {
	roundtrip(t, "test_groups")
}

func TestWriterRoundtripStrings(t *testing.T) {
	roundtrip(t, "test_strings")
}

func TestWriterRoundtripMultiDim(t *testing.T) {
	roundtrip(t, "test_multidim")
}
